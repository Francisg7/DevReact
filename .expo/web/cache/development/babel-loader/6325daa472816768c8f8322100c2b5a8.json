{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport invariant from 'invariant';\nimport { CameraType, ImageType } from \"./CameraModule.types\";\nimport * as Utils from \"./CameraUtils\";\nimport { FacingModeToCameraType, PictureSizes } from \"./constants\";\nimport * as CapabilityUtils from \"./CapabilityUtils\";\nexport { ImageType, CameraType };\n\nvar CameraModule = function () {\n  function CameraModule(videoElement) {\n    var _this = this;\n\n    _classCallCheck(this, CameraModule);\n\n    this.stream = null;\n    this.settings = null;\n\n    this.onCameraReady = function () {};\n\n    this.onMountError = function () {};\n\n    this._isStartingCamera = false;\n    this._autoFocus = 'continuous';\n    this._flashMode = 'off';\n    this._whiteBalance = 'continuous';\n    this._cameraType = CameraType.front;\n    this._zoom = 1;\n\n    this.getAvailablePictureSizes = function _callee(ratio) {\n      return _regeneratorRuntime.async(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.abrupt(\"return\", PictureSizes);\n\n            case 1:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    };\n\n    this.unmount = function () {\n      _this.settings = null;\n      _this.stream = null;\n    };\n\n    this.videoElement = videoElement;\n\n    if (this.videoElement) {\n      this.videoElement.addEventListener('loadedmetadata', function () {\n        _this._syncTrackCapabilities();\n      });\n    }\n  }\n\n  _createClass(CameraModule, [{\n    key: \"autoFocus\",\n    get: function get() {\n      return this._autoFocus;\n    }\n  }, {\n    key: \"setAutoFocusAsync\",\n    value: function setAutoFocusAsync(value) {\n      return _regeneratorRuntime.async(function setAutoFocusAsync$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!(value === this.autoFocus)) {\n                _context2.next = 2;\n                break;\n              }\n\n              return _context2.abrupt(\"return\");\n\n            case 2:\n              this._autoFocus = value;\n              _context2.next = 5;\n              return _regeneratorRuntime.awrap(this._syncTrackCapabilities());\n\n            case 5:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"flashMode\",\n    get: function get() {\n      return this._flashMode;\n    }\n  }, {\n    key: \"setFlashModeAsync\",\n    value: function setFlashModeAsync(value) {\n      return _regeneratorRuntime.async(function setFlashModeAsync$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              if (!(value === this.flashMode)) {\n                _context3.next = 2;\n                break;\n              }\n\n              return _context3.abrupt(\"return\");\n\n            case 2:\n              this._flashMode = value;\n              _context3.next = 5;\n              return _regeneratorRuntime.awrap(this._syncTrackCapabilities());\n\n            case 5:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"whiteBalance\",\n    get: function get() {\n      return this._whiteBalance;\n    }\n  }, {\n    key: \"setWhiteBalanceAsync\",\n    value: function setWhiteBalanceAsync(value) {\n      return _regeneratorRuntime.async(function setWhiteBalanceAsync$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              if (!(value === this.whiteBalance)) {\n                _context4.next = 2;\n                break;\n              }\n\n              return _context4.abrupt(\"return\");\n\n            case 2:\n              this._whiteBalance = value;\n              _context4.next = 5;\n              return _regeneratorRuntime.awrap(this._syncTrackCapabilities());\n\n            case 5:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this._cameraType;\n    }\n  }, {\n    key: \"setTypeAsync\",\n    value: function setTypeAsync(value) {\n      return _regeneratorRuntime.async(function setTypeAsync$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              if (!(value === this._cameraType)) {\n                _context5.next = 2;\n                break;\n              }\n\n              return _context5.abrupt(\"return\");\n\n            case 2:\n              this._cameraType = value;\n              _context5.next = 5;\n              return _regeneratorRuntime.awrap(this.resumePreview());\n\n            case 5:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"zoom\",\n    get: function get() {\n      return this._zoom;\n    }\n  }, {\n    key: \"setZoomAsync\",\n    value: function setZoomAsync(value) {\n      return _regeneratorRuntime.async(function setZoomAsync$(_context6) {\n        while (1) {\n          switch (_context6.prev = _context6.next) {\n            case 0:\n              if (!(value === this.zoom)) {\n                _context6.next = 2;\n                break;\n              }\n\n              return _context6.abrupt(\"return\");\n\n            case 2:\n              this._zoom = value;\n              _context6.next = 5;\n              return _regeneratorRuntime.awrap(this._syncTrackCapabilities());\n\n            case 5:\n            case \"end\":\n              return _context6.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"setPictureSize\",\n    value: function setPictureSize(value) {\n      if (value === this._pictureSize) {\n        return;\n      }\n\n      invariant(PictureSizes.includes(value), \"expo-camera: CameraModule.setPictureSize(): invalid size supplied \" + value + \", expected one of: \" + PictureSizes.join(', '));\n\n      var _value$split = value.split('x'),\n          _value$split2 = _slicedToArray(_value$split, 2),\n          width = _value$split2[0],\n          height = _value$split2[1];\n\n      var aspectRatio = parseFloat(width) / parseFloat(height);\n      this._pictureSize = value;\n    }\n  }, {\n    key: \"onCapabilitiesReady\",\n    value: function onCapabilitiesReady(track) {\n      var capabilities, constraints, _capabilities$zoom, min, max;\n\n      return _regeneratorRuntime.async(function onCapabilitiesReady$(_context7) {\n        while (1) {\n          switch (_context7.prev = _context7.next) {\n            case 0:\n              capabilities = track.getCapabilities();\n              constraints = {};\n\n              if (capabilities.zoom) {\n                _capabilities$zoom = capabilities.zoom, min = _capabilities$zoom.min, max = _capabilities$zoom.max;\n                constraints.zoom = Math.min(max, Math.max(min, this._zoom));\n              }\n\n              if (capabilities.focusMode) {\n                constraints.focusMode = CapabilityUtils.convertAutoFocusJSONToNative(this.autoFocus);\n              }\n\n              if (capabilities.torch) {\n                constraints.torch = CapabilityUtils.convertFlashModeJSONToNative(this.flashMode);\n              }\n\n              if (capabilities.whiteBalance) {\n                constraints.whiteBalance = this.whiteBalance;\n              }\n\n              _context7.next = 8;\n              return _regeneratorRuntime.awrap(track.applyConstraints({\n                advanced: [constraints]\n              }));\n\n            case 8:\n            case \"end\":\n              return _context7.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"_syncTrackCapabilities\",\n    value: function _syncTrackCapabilities() {\n      var _this2 = this;\n\n      return _regeneratorRuntime.async(function _syncTrackCapabilities$(_context8) {\n        while (1) {\n          switch (_context8.prev = _context8.next) {\n            case 0:\n              if (!this.stream) {\n                _context8.next = 3;\n                break;\n              }\n\n              _context8.next = 3;\n              return _regeneratorRuntime.awrap(Promise.all(this.stream.getTracks().map(function (track) {\n                return _this2.onCapabilitiesReady(track);\n              })));\n\n            case 3:\n            case \"end\":\n              return _context8.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"setVideoSource\",\n    value: function setVideoSource(stream) {\n      if ('srcObject' in this.videoElement) {\n        this.videoElement.srcObject = stream;\n      } else {\n        this.videoElement['src'] = window.URL.createObjectURL(stream);\n      }\n    }\n  }, {\n    key: \"setSettings\",\n    value: function setSettings(stream) {\n      this.settings = null;\n\n      if (stream && this.stream) {\n        this.settings = this.stream.getTracks()[0].getSettings();\n      }\n    }\n  }, {\n    key: \"setStream\",\n    value: function setStream(stream) {\n      this.stream = stream;\n      this.setSettings(stream);\n      this.setVideoSource(stream);\n    }\n  }, {\n    key: \"getActualCameraType\",\n    value: function getActualCameraType() {\n      if (this.settings) {\n        var _this$settings$facing = this.settings.facingMode,\n            facingMode = _this$settings$facing === void 0 ? 'user' : _this$settings$facing;\n        return FacingModeToCameraType[facingMode];\n      }\n\n      return null;\n    }\n  }, {\n    key: \"ensureCameraIsRunningAsync\",\n    value: function ensureCameraIsRunningAsync() {\n      return _regeneratorRuntime.async(function ensureCameraIsRunningAsync$(_context9) {\n        while (1) {\n          switch (_context9.prev = _context9.next) {\n            case 0:\n              if (this.stream) {\n                _context9.next = 3;\n                break;\n              }\n\n              _context9.next = 3;\n              return _regeneratorRuntime.awrap(this.resumePreview());\n\n            case 3:\n            case \"end\":\n              return _context9.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"resumePreview\",\n    value: function resumePreview() {\n      var stream;\n      return _regeneratorRuntime.async(function resumePreview$(_context10) {\n        while (1) {\n          switch (_context10.prev = _context10.next) {\n            case 0:\n              if (!this._isStartingCamera) {\n                _context10.next = 2;\n                break;\n              }\n\n              return _context10.abrupt(\"return\", null);\n\n            case 2:\n              this._isStartingCamera = true;\n              _context10.prev = 3;\n              this.pausePreview();\n              _context10.next = 7;\n              return _regeneratorRuntime.awrap(Utils.getStreamDevice(this.type));\n\n            case 7:\n              stream = _context10.sent;\n              this.setStream(stream);\n              this._isStartingCamera = false;\n              this.onCameraReady();\n              return _context10.abrupt(\"return\", stream);\n\n            case 14:\n              _context10.prev = 14;\n              _context10.t0 = _context10[\"catch\"](3);\n              this._isStartingCamera = false;\n              this.onMountError({\n                nativeEvent: _context10.t0\n              });\n\n            case 18:\n              return _context10.abrupt(\"return\", null);\n\n            case 19:\n            case \"end\":\n              return _context10.stop();\n          }\n        }\n      }, null, this, [[3, 14]], Promise);\n    }\n  }, {\n    key: \"takePicture\",\n    value: function takePicture(config) {\n      var base64 = Utils.captureImage(this.videoElement, config);\n      var capturedPicture = {\n        uri: base64,\n        base64: base64,\n        width: 0,\n        height: 0\n      };\n\n      if (this.settings) {\n        var _this$settings = this.settings,\n            _this$settings$width = _this$settings.width,\n            width = _this$settings$width === void 0 ? 0 : _this$settings$width,\n            _this$settings$height = _this$settings.height,\n            height = _this$settings$height === void 0 ? 0 : _this$settings$height;\n        capturedPicture.width = width;\n        capturedPicture.height = height;\n        capturedPicture.exif = this.settings;\n      }\n\n      if (config.onPictureSaved) {\n        config.onPictureSaved({\n          nativeEvent: {\n            data: capturedPicture,\n            id: config.id\n          }\n        });\n      }\n\n      return capturedPicture;\n    }\n  }, {\n    key: \"pausePreview\",\n    value: function pausePreview() {\n      if (!this.stream) {\n        return;\n      }\n\n      this.stream.getTracks().forEach(function (track) {\n        return track.stop();\n      });\n      this.setStream(null);\n    }\n  }]);\n\n  return CameraModule;\n}();\n\nexport default CameraModule;","map":{"version":3,"sources":["../../src/CameraModule/CameraModule.ts"],"names":[],"mappings":";;;;AAAA,OAAO,SAAP,MAAsB,WAAtB;AAGA,SAAS,UAAT,EAAsD,SAAtD;AACA,OAAO,KAAK,KAAZ;AACA,SAAS,sBAAT,EAAiC,YAAjC;AACA,OAAO,KAAK,eAAZ;AAEA,SAAS,SAAT,EAAoB,UAApB;;IAkBM,Y;AA+FJ,wBAAY,YAAZ,EAA0C;AAAA;;AAAA;;AA7F1C,SAAA,MAAA,GAA6B,IAA7B;AACA,SAAA,QAAA,GAAsC,IAAtC;;AACA,SAAA,aAAA,GAAuC,YAAK,CAAG,CAA/C;;AACA,SAAA,YAAA,GAAqC,YAAK,CAAG,CAA7C;;AAEA,SAAA,iBAAA,GAAoB,KAApB;AAEA,SAAA,UAAA,GAAqB,YAArB;AAYA,SAAA,UAAA,GAAqB,KAArB;AAYA,SAAA,aAAA,GAAwB,YAAxB;AAcA,SAAA,WAAA,GAA0B,UAAU,CAAC,KAArC;AAcA,SAAA,KAAA,GAAgB,CAAhB;;AAuKA,SAAA,wBAAA,GAA2B,iBAAO,KAAP;AAAA;AAAA;AAAA;AAAA;AAAA,+CAClB,YADkB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAA3B;;AAIA,SAAA,OAAA,GAAU,YAAK;AACb,MAAA,KAAI,CAAC,QAAL,GAAgB,IAAhB;AACA,MAAA,KAAI,CAAC,MAAL,GAAc,IAAd;AACD,KAHD;;AAxIE,SAAK,YAAL,GAAoB,YAApB;;AACA,QAAI,KAAK,YAAT,EAAuB;AACrB,WAAK,YAAL,CAAkB,gBAAlB,CAAmC,gBAAnC,EAAqD,YAAK;AACxD,QAAA,KAAI,CAAC,sBAAL;AACD,OAFD;AAGD;AACF;;;;SA5FD,eAAa;AACX,aAAO,KAAK,UAAZ;AACD;;;WACD,2BAAwB,KAAxB;AAAA;AAAA;AAAA;AAAA;AAAA,oBACM,KAAK,KAAK,KAAK,SADrB;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAIE,mBAAK,UAAL,GAAkB,KAAlB;AAJF;AAAA,+CAKQ,KAAK,sBAAL,EALR;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;SASA,eAAa;AACX,aAAO,KAAK,UAAZ;AACD;;;WACD,2BAAwB,KAAxB;AAAA;AAAA;AAAA;AAAA;AAAA,oBACM,KAAK,KAAK,KAAK,SADrB;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAIE,mBAAK,UAAL,GAAkB,KAAlB;AAJF;AAAA,+CAKQ,KAAK,sBAAL,EALR;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;SAUA,eAAgB;AACd,aAAO,KAAK,aAAZ;AACD;;;WAED,8BAA2B,KAA3B;AAAA;AAAA;AAAA;AAAA;AAAA,oBACM,KAAK,KAAK,KAAK,YADrB;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAIE,mBAAK,aAAL,GAAqB,KAArB;AAJF;AAAA,+CAKQ,KAAK,sBAAL,EALR;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;SAUA,eAAQ;AACN,aAAO,KAAK,WAAZ;AACD;;;WAED,sBAAmB,KAAnB;AAAA;AAAA;AAAA;AAAA;AAAA,oBACM,KAAK,KAAK,KAAK,WADrB;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAIE,mBAAK,WAAL,GAAmB,KAAnB;AAJF;AAAA,+CAKQ,KAAK,aAAL,EALR;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;SAUA,eAAQ;AACN,aAAO,KAAK,KAAZ;AACD;;;WAED,sBAAmB,KAAnB;AAAA;AAAA;AAAA;AAAA;AAAA,oBACM,KAAK,KAAK,KAAK,IADrB;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAKE,mBAAK,KAAL,GAAa,KAAb;AALF;AAAA,+CAMQ,KAAK,sBAAL,EANR;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;WASA,wBAAe,KAAf,EAA4B;AAC1B,UAAI,KAAK,KAAK,KAAK,YAAnB,EAAiC;AAC/B;AACD;;AACD,MAAA,SAAS,CACP,YAAY,CAAC,QAAb,CAAsB,KAAtB,CADO,yEAE8D,KAF9D,2BAEyF,YAAY,CAAC,IAAb,CAC9F,IAD8F,CAFzF,CAAT;;AAJ0B,yBAWF,KAAK,CAAC,KAAN,CAAY,GAAZ,CAXE;AAAA;AAAA,UAWnB,KAXmB;AAAA,UAWZ,MAXY;;AAc1B,UAAM,WAAW,GAAG,UAAU,CAAC,KAAD,CAAV,GAAoB,UAAU,CAAC,MAAD,CAAlD;AAEA,WAAK,YAAL,GAAoB,KAApB;AACD;;;WAWD,6BAA0B,KAA1B;AAAA;;AAAA;AAAA;AAAA;AAAA;AACQ,cAAA,YADR,GACuB,KAAK,CAAC,eAAN,EADvB;AAIQ,cAAA,WAJR,GASM,EATN;;AAWE,kBAAI,YAAY,CAAC,IAAjB,EAAuB;AAAA,qCAEA,YAAY,CAAC,IAFb,EAEb,GAFa,sBAEb,GAFa,EAER,GAFQ,sBAER,GAFQ;AAGrB,gBAAA,WAAW,CAAC,IAAZ,GAAmB,IAAI,CAAC,GAAL,CAAS,GAAT,EAAc,IAAI,CAAC,GAAL,CAAS,GAAT,EAAc,KAAK,KAAnB,CAAd,CAAnB;AACD;;AACD,kBAAI,YAAY,CAAC,SAAjB,EAA4B;AAC1B,gBAAA,WAAW,CAAC,SAAZ,GAAwB,eAAe,CAAC,4BAAhB,CAA6C,KAAK,SAAlD,CAAxB;AACD;;AACD,kBAAI,YAAY,CAAC,KAAjB,EAAwB;AACtB,gBAAA,WAAW,CAAC,KAAZ,GAAoB,eAAe,CAAC,4BAAhB,CAA6C,KAAK,SAAlD,CAApB;AACD;;AACD,kBAAI,YAAY,CAAC,YAAjB,EAA+B;AAC7B,gBAAA,WAAW,CAAC,YAAZ,GAA2B,KAAK,YAAhC;AACD;;AAxBH;AAAA,+CA0BQ,KAAK,CAAC,gBAAN,CAAuB;AAAE,gBAAA,QAAQ,EAAE,CAAC,WAAD;AAAZ,eAAvB,CA1BR;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;WA6BA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,mBACM,KAAK,MADX;AAAA;AAAA;AAAA;;AAAA;AAAA,+CAEU,OAAO,CAAC,GAAR,CAAY,KAAK,MAAL,CAAY,SAAZ,GAAwB,GAAxB,CAA4B,UAAA,KAAK;AAAA,uBAAI,MAAI,CAAC,mBAAL,CAAyB,KAAzB,CAAJ;AAAA,eAAjC,CAAZ,CAFV;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;WAMA,wBAAe,MAAf,EAA8D;AAC5D,UAAI,eAAe,KAAK,YAAxB,EAAsC;AACpC,aAAK,YAAL,CAAkB,SAAlB,GAA8B,MAA9B;AACD,OAFD,MAEO;AAEJ,aAAK,YAAL,CAAkB,KAAlB,IAAmC,MAAM,CAAC,GAAP,CAAW,eAAX,CAA2B,MAA3B,CAAnC;AACF;AACF;;;WAED,qBAAY,MAAZ,EAAsC;AACpC,WAAK,QAAL,GAAgB,IAAhB;;AACA,UAAI,MAAM,IAAI,KAAK,MAAnB,EAA2B;AACzB,aAAK,QAAL,GAAgB,KAAK,MAAL,CAAY,SAAZ,GAAwB,CAAxB,EAA2B,WAA3B,EAAhB;AACD;AACF;;;WAED,mBAAU,MAAV,EAAoC;AAClC,WAAK,MAAL,GAAc,MAAd;AACA,WAAK,WAAL,CAAiB,MAAjB;AACA,WAAK,cAAL,CAAoB,MAApB;AACD;;;WAED,+BAAmB;AACjB,UAAI,KAAK,QAAT,EAAmB;AAAA,oCAEe,KAAK,QAFpB,CAET,UAFS;AAAA,YAET,UAFS,sCAEI,MAFJ;AAGjB,eAAO,sBAAsB,CAAC,UAAD,CAA7B;AACD;;AACD,aAAO,IAAP;AACD;;;WAED;AAAA;AAAA;AAAA;AAAA;AAAA,kBACO,KAAK,MADZ;AAAA;AAAA;AAAA;;AAAA;AAAA,+CAEU,KAAK,aAAL,EAFV;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;WAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBACM,KAAK,iBADX;AAAA;AAAA;AAAA;;AAAA,iDAEW,IAFX;;AAAA;AAIE,mBAAK,iBAAL,GAAyB,IAAzB;AAJF;AAMI,mBAAK,YAAL;AANJ;AAAA,+CAOyB,KAAK,CAAC,eAAN,CAAsB,KAAK,IAA3B,CAPzB;;AAAA;AAOU,cAAA,MAPV;AAQI,mBAAK,SAAL,CAAe,MAAf;AACA,mBAAK,iBAAL,GAAyB,KAAzB;AACA,mBAAK,aAAL;AAVJ,iDAWW,MAXX;;AAAA;AAAA;AAAA;AAaI,mBAAK,iBAAL,GAAyB,KAAzB;AACA,mBAAK,YAAL,CAAkB;AAAE,gBAAA,WAAW;AAAb,eAAlB;;AAdJ;AAAA,iDAgBS,IAhBT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;WAmBA,qBAAY,MAAZ,EAAkC;AAChC,UAAM,MAAM,GAAG,KAAK,CAAC,YAAN,CAAmB,KAAK,YAAxB,EAAsC,MAAtC,CAAf;AAEA,UAAM,eAAe,GAAoB;AACvC,QAAA,GAAG,EAAE,MADkC;AAEvC,QAAA,MAAM,EAAN,MAFuC;AAGvC,QAAA,KAAK,EAAE,CAHgC;AAIvC,QAAA,MAAM,EAAE;AAJ+B,OAAzC;;AAOA,UAAI,KAAK,QAAT,EAAmB;AAAA,6BACiB,KAAK,QADtB;AAAA,kDACT,KADS;AAAA,YACT,KADS,qCACD,CADC;AAAA,mDACE,MADF;AAAA,YACE,MADF,sCACW,CADX;AAEjB,QAAA,eAAe,CAAC,KAAhB,GAAwB,KAAxB;AACA,QAAA,eAAe,CAAC,MAAhB,GAAyB,MAAzB;AAEA,QAAA,eAAe,CAAC,IAAhB,GAAuB,KAAK,QAA5B;AACD;;AAED,UAAI,MAAM,CAAC,cAAX,EAA2B;AACzB,QAAA,MAAM,CAAC,cAAP,CAAsB;AAAE,UAAA,WAAW,EAAE;AAAE,YAAA,IAAI,EAAE,eAAR;AAAyB,YAAA,EAAE,EAAE,MAAM,CAAC;AAApC;AAAf,SAAtB;AACD;;AACD,aAAO,eAAP;AACD;;;WAED,wBAAY;AACV,UAAI,CAAC,KAAK,MAAV,EAAkB;AAChB;AACD;;AACD,WAAK,MAAL,CAAY,SAAZ,GAAwB,OAAxB,CAAgC,UAAA,KAAK;AAAA,eAAI,KAAK,CAAC,IAAN,EAAJ;AAAA,OAArC;AACA,WAAK,SAAL,CAAe,IAAf;AACD;;;;;;AAaH,eAAe,YAAf","sourcesContent":["import invariant from 'invariant';\n\nimport { PictureOptions } from '../Camera.types';\nimport { CameraType, CapturedPicture, CaptureOptions, ImageType } from './CameraModule.types';\nimport * as Utils from './CameraUtils';\nimport { FacingModeToCameraType, PictureSizes } from './constants';\nimport * as CapabilityUtils from './CapabilityUtils';\n\nexport { ImageType, CameraType, CaptureOptions };\n\n/*\n * TODO: Bacon: Add more props for Android\n *\n * aspectRatio: { min (0.00033), max (4032) }\n * colorTemperature: MediaSettingsRange  (max: 7000, min: 2850, step: 50)\n * exposureCompensation: MediaSettingsRange (max: 2, min: -2, step: 0.1666666716337204)\n * exposureMode: 'continuous' | 'manual'\n * frameRate: { min: (1), max: (60) }\n * iso: MediaSettingsRange (max: 3200, min: 50, step: 1)\n * width: { min: 1, max}\n * height: { min: 1, max}\n */\n\ntype OnCameraReadyListener = () => void;\ntype OnMountErrorListener = ({ nativeEvent: Error }) => void;\n\nclass CameraModule {\n  videoElement: HTMLVideoElement;\n  stream: MediaStream | null = null;\n  settings: MediaTrackSettings | null = null;\n  onCameraReady: OnCameraReadyListener = () => {};\n  onMountError: OnMountErrorListener = () => {};\n  _pictureSize?: string;\n  _isStartingCamera = false;\n\n  _autoFocus: string = 'continuous';\n  get autoFocus(): string {\n    return this._autoFocus;\n  }\n  async setAutoFocusAsync(value: string): Promise<void> {\n    if (value === this.autoFocus) {\n      return;\n    }\n    this._autoFocus = value;\n    await this._syncTrackCapabilities();\n  }\n\n  _flashMode: string = 'off';\n  get flashMode(): string {\n    return this._flashMode;\n  }\n  async setFlashModeAsync(value: string): Promise<void> {\n    if (value === this.flashMode) {\n      return;\n    }\n    this._flashMode = value;\n    await this._syncTrackCapabilities();\n  }\n\n  _whiteBalance: string = 'continuous';\n\n  get whiteBalance(): string {\n    return this._whiteBalance;\n  }\n\n  async setWhiteBalanceAsync(value: string): Promise<void> {\n    if (value === this.whiteBalance) {\n      return;\n    }\n    this._whiteBalance = value;\n    await this._syncTrackCapabilities();\n  }\n\n  _cameraType: CameraType = CameraType.front;\n\n  get type(): CameraType {\n    return this._cameraType;\n  }\n\n  async setTypeAsync(value: CameraType) {\n    if (value === this._cameraType) {\n      return;\n    }\n    this._cameraType = value;\n    await this.resumePreview();\n  }\n\n  _zoom: number = 1;\n\n  get zoom(): number {\n    return this._zoom;\n  }\n\n  async setZoomAsync(value: number): Promise<void> {\n    if (value === this.zoom) {\n      return;\n    }\n    //TODO: Bacon: IMP on non-android devices\n    this._zoom = value;\n    await this._syncTrackCapabilities();\n  }\n\n  setPictureSize(value: string) {\n    if (value === this._pictureSize) {\n      return;\n    }\n    invariant(\n      PictureSizes.includes(value),\n      `expo-camera: CameraModule.setPictureSize(): invalid size supplied ${value}, expected one of: ${PictureSizes.join(\n        ', '\n      )}`\n    );\n\n    const [width, height] = value.split('x');\n    //TODO: Bacon: IMP\n    // eslint-disable-next-line\n    const aspectRatio = parseFloat(width) / parseFloat(height);\n\n    this._pictureSize = value;\n  }\n\n  constructor(videoElement: HTMLVideoElement) {\n    this.videoElement = videoElement;\n    if (this.videoElement) {\n      this.videoElement.addEventListener('loadedmetadata', () => {\n        this._syncTrackCapabilities();\n      });\n    }\n  }\n\n  async onCapabilitiesReady(track: MediaStreamTrack): Promise<void> {\n    const capabilities = track.getCapabilities() as any;\n\n    // Create an empty object because if you set a constraint that isn't available an error will be thrown.\n    const constraints: {\n      zoom?: number;\n      torch?: boolean;\n      whiteBalance?: string;\n      focusMode?: string;\n    } = {};\n\n    if (capabilities.zoom) {\n      // TODO: Bacon: We should have some async method for getting the (min, max, step) externally\n      const { min, max } = capabilities.zoom;\n      constraints.zoom = Math.min(max, Math.max(min, this._zoom));\n    }\n    if (capabilities.focusMode) {\n      constraints.focusMode = CapabilityUtils.convertAutoFocusJSONToNative(this.autoFocus);\n    }\n    if (capabilities.torch) {\n      constraints.torch = CapabilityUtils.convertFlashModeJSONToNative(this.flashMode);\n    }\n    if (capabilities.whiteBalance) {\n      constraints.whiteBalance = this.whiteBalance;\n    }\n\n    await track.applyConstraints({ advanced: [constraints] as any });\n  }\n\n  async _syncTrackCapabilities(): Promise<void> {\n    if (this.stream) {\n      await Promise.all(this.stream.getTracks().map(track => this.onCapabilitiesReady(track)));\n    }\n  }\n\n  setVideoSource(stream: MediaStream | MediaSource | Blob | null): void {\n    if ('srcObject' in this.videoElement) {\n      this.videoElement.srcObject = stream;\n    } else {\n      // TODO: Bacon: Check if needed\n      (this.videoElement['src'] as any) = window.URL.createObjectURL(stream);\n    }\n  }\n\n  setSettings(stream: MediaStream | null): void {\n    this.settings = null;\n    if (stream && this.stream) {\n      this.settings = this.stream.getTracks()[0].getSettings();\n    }\n  }\n\n  setStream(stream: MediaStream | null): void {\n    this.stream = stream;\n    this.setSettings(stream);\n    this.setVideoSource(stream);\n  }\n\n  getActualCameraType(): CameraType | null {\n    if (this.settings) {\n      // On desktop no value will be returned, in this case we should assume the cameraType is 'front'\n      const { facingMode = 'user' } = this.settings;\n      return FacingModeToCameraType[facingMode];\n    }\n    return null;\n  }\n\n  async ensureCameraIsRunningAsync(): Promise<void> {\n    if (!this.stream) {\n      await this.resumePreview();\n    }\n  }\n\n  async resumePreview(): Promise<MediaStream | null> {\n    if (this._isStartingCamera) {\n      return null;\n    }\n    this._isStartingCamera = true;\n    try {\n      this.pausePreview();\n      const stream = await Utils.getStreamDevice(this.type);\n      this.setStream(stream);\n      this._isStartingCamera = false;\n      this.onCameraReady();\n      return stream;\n    } catch (error) {\n      this._isStartingCamera = false;\n      this.onMountError({ nativeEvent: error });\n    }\n    return null;\n  }\n\n  takePicture(config: PictureOptions): CapturedPicture {\n    const base64 = Utils.captureImage(this.videoElement, config);\n\n    const capturedPicture: CapturedPicture = {\n      uri: base64,\n      base64,\n      width: 0,\n      height: 0,\n    };\n\n    if (this.settings) {\n      const { width = 0, height = 0 } = this.settings;\n      capturedPicture.width = width;\n      capturedPicture.height = height;\n      // TODO: Bacon: verify/enforce exif shape.\n      capturedPicture.exif = this.settings;\n    }\n\n    if (config.onPictureSaved) {\n      config.onPictureSaved({ nativeEvent: { data: capturedPicture, id: config.id } });\n    }\n    return capturedPicture;\n  }\n\n  pausePreview(): void {\n    if (!this.stream) {\n      return;\n    }\n    this.stream.getTracks().forEach(track => track.stop());\n    this.setStream(null);\n  }\n\n  // TODO: Bacon: we don't even use ratio in native...\n  getAvailablePictureSizes = async (ratio: string): Promise<string[]> => {\n    return PictureSizes;\n  };\n\n  unmount = () => {\n    this.settings = null;\n    this.stream = null;\n  };\n}\n\nexport default CameraModule;\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}